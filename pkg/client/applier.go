// Copyright Mia srl
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package client

import (
	"context"
	"fmt"
	"slices"
	"time"

	"github.com/mia-platform/jpl/internal/poller"
	"github.com/mia-platform/jpl/pkg/event"
	"github.com/mia-platform/jpl/pkg/generator"
	"github.com/mia-platform/jpl/pkg/inventory"
	"github.com/mia-platform/jpl/pkg/resource"
	"github.com/mia-platform/jpl/pkg/runner"
	"github.com/mia-platform/jpl/pkg/runner/task"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/sets"
	"k8s.io/client-go/dynamic"
)

// Applier can be used for appling a list of resources to a remote api-server
type Applier struct {
	mapper      meta.RESTMapper
	client      dynamic.Interface
	infoFetcher task.InfoFetcher

	runner        runner.TaskRunner
	inventory     inventory.Store
	generators    []generator.Interface
	pollerBuilder poller.Builder
}

// ApplierOptions options for the apply step
type ApplierOptions struct {
	DryRun       bool
	Timeout      time.Duration
	FieldManager string
}

// Run will apply the passed objects to a remote api-server
func (a *Applier) Run(ctx context.Context, objects []*unstructured.Unstructured, options ApplierOptions) <-chan event.Event {
	eventChannel := make(chan event.Event)

	go func() {
		defer close(eventChannel)

		applierCtx := ctx
		if options.Timeout > 0 {
			var cancel context.CancelFunc
			applierCtx, cancel = context.WithTimeout(ctx, options.Timeout)
			defer cancel()
		}

		generatedObject, abort := a.generateObjects(objects, eventChannel)
		if abort {
			return
		}

		objects = append(objects, generatedObject...)
		remoteObjects, err := a.loadObjectsFromInventory(applierCtx)
		if err != nil {
			handleError(eventChannel, err)
			return
		}

		objectsToPrune := findObjectsToPrune(remoteObjects, objects)
		manager := inventory.NewManager(a.inventory, remoteObjects)

		queueBuilder := QueueBuilder{
			Client:        a.client,
			Mapper:        a.mapper,
			Manager:       manager,
			InfoFetcher:   a.infoFetcher,
			PollerBuilder: a.pollerBuilder,
		}
		queueOptions := QueueOptions{
			DryRun:       options.DryRun,
			Prune:        true,
			FieldManager: options.FieldManager,
		}

		contextState := &RunnerState{
			eventChannel: eventChannel,
			manager:      manager,
			context:      applierCtx,
		}

		tasksQueue := queueBuilder.
			WithObjects(objects).
			WithPruneObjects(objectsToPrune).
			Build(queueOptions)

		if err := a.runner.RunWithQueue(contextState, tasksQueue); err != nil {
			handleError(eventChannel, err)
		}
	}()

	return eventChannel
}

// generateObjects will cycle through all the generator of the applier and accumulate any object generated by them,
// return false if an error is encountered
func (a *Applier) generateObjects(objects []*unstructured.Unstructured, eventChannel chan event.Event) ([]*unstructured.Unstructured, bool) {
	var generatedObject []*unstructured.Unstructured
	for _, rg := range a.generators {
		for _, obj := range objects {
			objMetadata := meta.AsPartialObjectMetadata(obj)
			objMetadata.TypeMeta = metav1.TypeMeta{
				Kind:       obj.GetKind(),
				APIVersion: obj.GetAPIVersion(),
			}

			if !rg.CanHandleResource(objMetadata) {
				continue
			}

			generated, err := rg.Generate(obj)
			if err != nil {
				handleError(eventChannel, fmt.Errorf("generate resource failed: %w", err))
				return generatedObject, true
			}
			generatedObject = append(generatedObject, generated...)
		}
	}

	return generatedObject, false
}

// loadObjectsFromInventory return the array of Unstructured objects that are being tracked in the inventory.
// It will skip objects that are not found, and return an error only in case some other problem is encountered
// during retrivial, like network problems, or missing permissions
func (a *Applier) loadObjectsFromInventory(ctx context.Context) ([]*unstructured.Unstructured, error) {
	objIDs, err := a.inventory.Load(ctx)
	if err != nil {
		return nil, err
	}

	remoteObjects := make([]*unstructured.Unstructured, 0, len(objIDs))
	for objID := range objIDs {
		obj, err := a.getObject(ctx, objID)
		if err != nil {
			if meta.IsNoMatchError(err) || apierrors.IsNotFound(err) {
				continue
			}
			return nil, err
		}

		remoteObjects = append(remoteObjects, obj)
	}

	return slices.Clip(remoteObjects), nil
}

func (a *Applier) getObject(ctx context.Context, id resource.ObjectMetadata) (*unstructured.Unstructured, error) {
	mapping, err := a.mapper.RESTMapping(schema.GroupKind{Group: id.Group, Kind: id.Kind})
	if err != nil {
		return nil, err
	}
	return a.client.Resource(mapping.Resource).Namespace(id.Namespace).Get(ctx, id.Name, metav1.GetOptions{})
}

// findObjectsToPrune return the element in first that are not present in second
func findObjectsToPrune(first []*unstructured.Unstructured, second []*unstructured.Unstructured) []*unstructured.Unstructured {
	firstSet := make(sets.Set[resource.ObjectMetadata], len(first))
	for _, obj := range first {
		firstSet.Insert(resource.ObjectMetadataFromUnstructured(obj))
	}

	for _, obj := range second {
		firstSet.Delete(resource.ObjectMetadataFromUnstructured(obj))
	}

	returnedObjects := make([]*unstructured.Unstructured, 0, len(firstSet))
	for _, obj := range first {
		if firstSet.Has(resource.ObjectMetadataFromUnstructured(obj)) {
			returnedObjects = append(returnedObjects, obj)
		}
	}

	return returnedObjects
}

// handleError send a TypeError event in the channel with err payload
func handleError(channel chan event.Event, err error) {
	channel <- event.Event{
		Type: event.TypeError,
		ErrorInfo: event.ErrorInfo{
			Error: err,
		},
	}
}
